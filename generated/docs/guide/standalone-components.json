{"id":"guide/standalone-components","title":"独立组件入门","contents":"<div class=\"content\">\n  <h1 id=\"getting-started-with-standalone-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44nde9ehz1fumjz2z2juyg2cr\">独立组件入门<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bda3rt3e2ylt4n7v9b5j0zx9\"><strong>独立组件</strong>提供了一种简化的方式来构建 Angular 应用程序。独立组件、指令和管道旨在通过减少对 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的需求来简化创作体验。现有应用程序可以选择性地以增量方式采用新的独立风格，而无需任何重大更改。</p>\n<h2 id=\"creating-standalone-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18m1qja3ye7oav08800iwq0ng\">创建独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"video-container\">\n<video controls>\n      <source src=\"https://videos.angular.cn/x5PZwb4XurU.webm\" type=\"video/webm\">\n      <source src=\"https://videos.angular.cn/x5PZwb4XurU.mp4\" type=\"video/mp4\">\n      <track src=\"/assets/videos/x5PZwb4XurU.en.vtt\" label=\"English\" kind=\"subtitles\" srclang=\"en\">\n      <track src=\"/assets/videos/x5PZwb4XurU.cn.vtt\" label=\"简体中文\" kind=\"subtitles\" srclang=\"zh-CN\" default>\n      <track src=\"/assets/videos/x5PZwb4XurU.tw.vtt\" label=\"正體中文\" kind=\"subtitles\" srclang=\"zh-TW\">\n    </video>\n</div>\n<h3 id=\"the-standalone-flag-and-component-imports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27v346llrmpay4zk6xu01z57a\"><code>standalone</code> 标志和组件 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d7gc7ylmp6ddvrs2uvw31pcr\">组件、指令和管道现在可以标记为 <code>standalone: true</code>。标记为独立的 Angular 类不需要在 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中声明（如果你尝试，Angular 编译器会报告错误）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ergxrr330e0cqanz8a0rqtdu\">独立组件直接指定它们的依赖项，而不是通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 获取它们。例如，如果 <code>PhotoGalleryComponent</code> 是独立组件，它可以直接导入另一个独立组件 <code>ImageGridComponent</code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  imports: [ImageGridComponent],\n  template: `\n    ... &lt;image-grid [images]=\"imageList\"&gt;&lt;/image-grid&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // component logic\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7yglrxkjgj5cqbi75yh8bck8y\"><code>imports</code> 也可用于引用独立指令和管道。通过这种方式，可以编写独立组件，而无需创建 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 来管理模板依赖项。</p>\n<h3 id=\"using-existing-ngmodules-in-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z44izx5xlo16sk4z7tx3m840\">在独立组件中使用现有的 NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccl1o3lnl4887guhgbpg35381\">编写独立组件时，你可能希望在组件的模板中使用其他组件、指令或管道。其中某些依赖项可能不会标记为独立，而是由现有的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 声明和导出。在这种情况下，你可以将 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 直接导入到独立组件中：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  // an existing module is imported directly into a standalone component\n  imports: [MatButtonModule],\n  template: `\n    ...\n    &lt;button mat-button&gt;Next Page&lt;/button&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // logic\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xoj1lt8i34rldbgt5uhqmgc4\">你可以在模板中将独立组件与现有的基于 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的库或依赖项一起使用。独立组件可以充分利用现有的 Angular 库生态系统。</p>\n<h2 id=\"using-standalone-components-in-ngmodule-based-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csdyebx7ip7nm88rzhi0qi63f\">在基于 NgModule 的应用程序中使用独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92l5s4g499x8i968gpqhjyqon\">独立组件也可以导入到现有的基于 NgModules 的上下文中。这允许现有应用程序（今天使用 NgModules）逐步采用新的独立风格的组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6h966wcshscf93fk4cljxxxg\">你可以像导入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 一样导入独立组件（或指令或管道）- 使用 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [AlbumComponent],\n  exports: [AlbumComponent], \n  imports: [PhotoGalleryComponent],\n})\nexport class AlbumModule {}\n</code-example>\n<h2 id=\"bootstrapping-an-application-using-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37516qx084m3046kwaynvicr9\">使用独立组件引导应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4js1699m07ki50cw5p3l7bnsv\">通过使用独立组件作为应用程序的根组件，可以在没有任何 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情况下引导 Angular 应用程序。这是使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API 来完成的：</p>\n<code-example language=\"ts\">\n// in the main.ts file\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>} from '@angular/platform-browser';\nimport {PhotoAppComponent} from './app/photo.app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent);\n</code-example>\n<h3 id=\"configuring-dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wsln13zy2pmixcg7na6ijsvv\">配置依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqwb86673l9pn0e5e2zsd3l9i\">引导应用程序时，你通常希望配置 Angular 的依赖注入并提供配置值或服务以在整个应用程序中使用。你可以将这些作为提供者传递给 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eklgtvkuw09xdx4zx2p0yauos\">独立的引导操作基于显式配置 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 列表以进行依赖注入。在 Angular 中，带有 <code>provide</code> 前缀的函数可用于配置不同的系统，而不必导入 NgModules。比如 <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> 可用于 <code>RouterModule.forRoot</code> 中以配置路由器：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([/* app routes */]),\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rfs9pkr2o0d28z459quhhly2\">许多第三方库也已更新以支持这种 <code>provide</code> 配置模式。如果某个库仅为其 DI 配置提供 NgModule API，你可以用 <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 实用函数，来将它与 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 和其他独立上下文一起使用：</p>\n<code-example language=\"ts\">\nimport {LibraryModule} from 'ngmodule-based-library';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(\n      LibraryModule.forRoot()\n    ),\n  ]\n});\n</code-example>\n<h2 id=\"routing-and-lazy-loading\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ymwmxmucdty68np7huxrwo79\">路由和惰性加载<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l4z33tr71e5euis1fmvs11mv\">路由器 API 进行了更新和简化，以利用独立组件的优势：在许多常见的惰性加载场景中不再需要 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<h3 id=\"lazy-loading-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r3j1gudb23rl5uel2i0y2bdx\">惰性加载独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3e8yei0xpkb81sixh9657tlx\">任何路由都可以用 <code>loadComponent</code> 惰性加载其路由到的独立组件：</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadComponent: () =&gt; import('./admin/panel.component').then(mod =&gt; mod.AdminPanelComponent)},\n  // ...\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b62j625z01nxq3wjn7c44scye\">只要加载的组件是独立的，就可以用。</p>\n<h3 id=\"lazy-loading-many-routes-at-once\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1eu7r6cy2icc7ngk26zlfea2x\">一次惰性加载多个路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84ohngzj4taxg7usml1g04btk\"><code>loadChildren</code> 操作现在支持加载一组新的子 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，而无需编写惰性加载的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 来导入 <code>RouterModule.forChild</code> 来声明路由。当以这种方式加载的每个路由都使用独立组件时，这会起作用。</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ...\n];\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n];\n</code-example>\n<h3 id=\"lazy-loading-and-default-exports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dld3wxrs5ggzho8i62umgt0zz\">惰性加载和默认导出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-and-default-exports\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94wbas59bqa3f9gy1f48ws4k8\">使用 <code>loadChildren</code> 和 <code>loadComponent</code> 时，路由器会理解并使用 <code>default</code> 导出来自动解包动态 <code>import()</code> 调用。你可以利用这一点跳过 <code>.then()</code> 进行此类惰性加载操作。</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes')},\n  // ...\n];\n\n// In admin/routes.ts:\nexport default [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n] satisfies <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[];\n</code-example>\n<h3 id=\"providing-services-to-a-subset-of-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rmyxkwkitaqko2f4bxd0keq\">为路由的子集提供服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q56bei3qzbqanj0sxgxh20bj\"><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的惰性加载 API （ <code>loadChildren</code>）在加载路由的惰性加载的子项时会创建一个新的“模块”注入器。此特性通常可用于仅向应用程序中的一部分路由提供服务。例如，如果 <code>/admin</code> 下的所有路由都使用 <code>loadChildren</code> 边界来限定范围，则可以仅向这些路由提供仅限管理的服务。执行此操作需要使用 <code>loadChildren</code> API，即使惰性加载有问题的路由不是必要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rbra9vs0y1aeoyn6ujsbbbzs\">路由器现在支持在 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 上显式指定其他 <code>providers</code>，这允许相同的范围限定，而无需惰性加载或 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。例如，<code>/admin</code> 路由结构中的范围服务将类似于：</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {\n    path: 'admin',\n    providers: [\n      AdminService,\n      {provide: ADMIN_API_KEY, useValue: '12345'},\n    ],\n    children: [\n      {path: 'users', component: AdminUsersComponent},\n      {path: 'teams', component: AdminTeamsComponent},\n    ],\n  },\n  // ... other application routes that don't\n  //     have access to ADMIN_API_KEY or AdminService.\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5i8zuatavam15qid942nyibl\">也可以将 <code>providers</code> 与额外路由配置的 <code>loadChildren</code> 结合使用，以实现与惰性加载带有额外路由和路由级服务提供者的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相同的效果。此示例配置与上面相同的提供者/子路由，但在惰性加载边界之后：</p>\n<code-example language=\"ts\">\n// Main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24vb7mdokkl1hofaqn97srsb9\">请注意这里使用了空路径路由来定义供所有子路由共享的宿主 <code>providers</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vb96ororzlb6is86qyxzjdh2\"><code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 也可用于将现有的基于 NgModule 的 DI 配置导入到路由 <code>providers</code> 中。</p>\n<h2 id=\"advanced-topics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74227uv8w0mnb9jwmm0p94era\">高级主题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33z2ohbbbqwr4xbxermuj7igl\">本节会更详细地介绍仅与更高级的使用模式相关的。第一次了解独立组件、指令和管道时，你可以安全地跳过本节。</p>\n<h3 id=\"standalone-components-for-library-authors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3c5qn1z3lkpqmr6k4ksx0y5j\">针对库作者的独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n9jckhta36radetpdqagya9m\">独立的组件、指令和管道可以从导入它们的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中导出：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ImageCarouselComponent, ImageSlideComponent],\n  exports: [ImageCarouselComponent, ImageSlideComponent],\n})\nexport class CarouselModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kszlffe2nw2c39o7gqknseib\">此模式对于发布一组合作指令的 Angular 库很有用。在上面的示例中，<code>ImageCarouselComponent</code> 和 <code>ImageSlideComponent</code> 需要出现在模板中，以构建一个逻辑上的“轮播小部件”。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cp4acw51pipi18mpofwge5v7a\">作为发布 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的替代方案，库作者可能希望导出一个合作指令数组：</p>\n<code-example language=\"ts\">\nexport const CAROUSEL_DIRECTIVES = [ImageCarouselComponent, ImageSlideComponent] as const;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ar389fevc6i39o35on6azfjky\">这样的数组可以由使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的应用程序导入并添加到 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>。请注意 TypeScript 的 <code>as const</code> 构造的存在：它为 Angular 编译器提供了正确编译所需的额外信息，并且是一种推荐的实践（因为它使导出的数组从 TypeScript 的角度来看是不可变的）。</p>\n<h3 id=\"dependency-injection-and-injectors-hierarchy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzn0gp7mf7wuawenn4b4mfp9h\">依赖注入和注入器层次结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ll7w5g6p519duq60l3zyjx1e\">Angular 应用程序可以通过指定一组可用的提供者来配置依赖注入。在典型应用中，有两种不同的注入器类型：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz46v30cinlq3q1a40231wc2t\">具有在 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code> 中配置的服务提供者的<strong>模块注入器</strong>。这些应用程序范围的提供者对模块注入器中配置的所有组件以及其他服务可见。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yf65lhrfs8h9rvm7a3ge6fy5\">在 <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> 或 <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code> 中配置的<strong>节点注入器</strong>。这些提供者仅对给定组件及其所有子项可见。</li>\n</ul>\n<h4 id=\"environment-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3dvfz1nc1jqhdfhl9jg7f0vb\">环境注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5afl67b6ul1d9j61nb9kqw0kl\">使 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 变成可选的将需要一种新方法来用应用程序范围的提供者（例如<a href=\"/api/common/http/HttpClient\">HttpClient</a>）配置“模块”注入器。在独立应用程序（使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 创建的）中，可以在引导过程中在 <code>providers</code> 选项中配置“模块”提供者：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"418mmyl28e5btkqp843flzsfp\">新的启动 API 使我们能够在不使用 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情况下配置“模块注入器”。在这种意义上，名称中的“模块”部分已不再相关，因此我们决定引入一个新术语：“环境注入器”。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a48r2ejy52oxkpalkm878ysk5\">可以用以下方法之一配置环境注入器：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3k4m15qnuy225n2vuxds0v0i\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>（在通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 引导的应用程序中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxid7ha5yhqkkfza9t93wdoih\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>（在基于 NgModule 以及“独立”应用程序中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nwog0r66mppbi37feswepq3y\"><code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 调用中的 <code>providers</code> 选项（在完全“独立”的应用程序中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9182carrdj0co327shfc2712f\"><code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置中的 <code>providers</code> 字段。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9of7x07qw0yyvf40p4xwleiev\">Angular v14 引入了一种新的 TypeScript 类型 <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> 来表示这种新命名。附带的 <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API 使得以编程方式创建环境注入器成为可能：</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>} from '@angular/core';\n\nconst parentInjector = … // existing environment injector\nconst childInjector = <a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([{provide: PhotosService, useClass: CustomPhotosService}], parentInjector);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hksnoxqwtxt1zlwncow49d64\">环境注入器还有一个额外的能力：它们可以在创建环境注入器时执行初始化逻辑（类似于创建模块注入器时执行的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 构造函数）：</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>, <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>} from '@angular/core';\n\n<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([\n{provide: PhotosService, useClass: CustomPhotosService},\n{provide: <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>, useValue: () =&gt; {\n        console.log(\"This function runs when this <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a> gets created\");\n}}\n]);\n</code-example>\n<h4 id=\"standalone-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3o8c23bhtqf8tb89xulubr2ag\">独立注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4e913smfjx2renry4m8g09nl\">实际上，依赖注入器层次结构在使用独立组件的应用程序中稍微复杂一些。让我们考虑以下示例：</p>\n<code-example language=\"ts\">\n// an existing \"datepicker\" component with an <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; selector: 'datepicker',\n&nbsp; &nbsp; &nbsp; &nbsp; template: '...',\n})\nclass DatePickerComponent {\n  constructor(private calendar: CalendarService) {}\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; declarations: [DatePickerComponent],\n&nbsp; &nbsp; &nbsp; &nbsp; exports: [DatePickerComponent],\n&nbsp; &nbsp; &nbsp; &nbsp; providers: [CalendarService],\n})\nclass DatePickerModule {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; selector: 'date-modal',\n&nbsp; &nbsp; &nbsp; &nbsp; template: '&lt;datepicker&gt;&lt;/datepicker&gt;',\n&nbsp; &nbsp; &nbsp; &nbsp; standalone: true,\n&nbsp; &nbsp; &nbsp; &nbsp; imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5aqp8j98cn2x49wqoqta2cx0a\">在上面的示例中，组件 <code>DateModalComponent</code> 是独立的 - 它可以直接使用，并且没有需要导入才能使用它的 NgModule。但是，<code>DateModalComponent</code> 有一个依赖项 <code>DatePickerComponent</code>，它是通过其 NgModule（<code>DatePickerModule</code>）导入的。此 NgModule 可以声明 <code>DatePickerComponent</code> 正常运行所需的提供者（在本例中为：<code>CalendarService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gaexkm3pojv7gum78jp3om1y\">当 Angular 创建一个独立组件时，需要确保当前注入器具有独立组件的所有必要服务依赖，包括基于 NgModule 的依赖。为了保证这一点，在某些情况下，Angular 将创建一个新的“独立注入器”作为当前环境注入器的子级。今天，在所有已启动的独立组件中都会发生这种情况：它将是根环境注入器的子级。相同的规则适用于动态创建的（例如通过路由器或 \n<code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API）的独立组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce39sbjyuoifgqm3steo6xgen\">创建了一个单独的独立注入器，以确保独立组件导入的提供者与应用程序的其余部分“隔离”。这让我们将独立组件视为真正独立的部分，不能将它们的实现细节“泄漏”给应用程序的其余部分。</p>\n<h4 id=\"resolve-circular-dependencies-with-a-forward-class-reference\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o5jeozrasd76el1zcztbmngl\">使用前向类引用解决循环依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmp3ierm3wcwjw6n0v5nonun5\">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5reucw1ujmbqvnm50mzl0v80i\">这通常不是问题，但有时循环引用是不可避免的。例如，当类“A”引用类“B”而“B”也引用“A”时。其中之一必须首先定义。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfqkh7c3nromqvuvx0vfbeb8s\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函数创建了一个 Angular 稍后可以解析的间接引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35rl4ixrwq5n32ep2s4tdrna6\">例如，当独立父组件导入独立子组件时会发生这种情况，反之亦然。你可以使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 函数解决此循环依赖问题。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `&lt;app-child [hideParent]=\"hideParent\"&gt;&lt;/app-child&gt;`,\n})\nexport class ParentComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; ParentComponent)],\n  selector: 'app-child',\n  template: `&lt;app-parent *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!hideParent\"&gt;&lt;/app-parent&gt;`,\n})\nexport class ChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3e14ypmi1ztn3vgvtoli77h28\">这种类型的导入可能会导致组件实例化期间出现无限递归。请确保这种递归具有停止条件，会在某种时刻停止。</p>\n</div>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/common/NgOptimizedImage\n - api/core/Component\n - api/core/Directive\n - api/core/Pipe\n - api/core/createEnvironmentInjector\n - api/core/importProvidersFrom\n - api/platform-browser\n - api/platform-browser/bootstrapApplication\n - guide/architecture-components\n - guide/deprecations\n - guide/glossary\n - guide/pipe-template\n - guide/pipes\n - guide/pipes-transform-data\n - guide/standalone-migration\n - guide/update-to-version-15\n-->\n<!-- links from this doc:\n - /api/common/http/HttpClient\n - api/common/CommonModule\n - api/common/NgIf\n - api/core/Component\n - api/core/Component#viewProviders\n - api/core/Directive#providers\n - api/core/ENVIRONMENT_INITIALIZER\n - api/core/EnvironmentInjector\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Provider\n - api/core/ViewContainerRef\n - api/core/createEnvironmentInjector\n - api/core/forwardRef\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - api/router/ROUTES\n - api/router/Route\n - api/router/provideRouter\n - guide/standalone-components#advanced-topics\n - guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\n - guide/standalone-components#configuring-dependency-injection\n - guide/standalone-components#creating-standalone-components\n - guide/standalone-components#dependency-injection-and-injectors-hierarchy\n - guide/standalone-components#environment-injectors\n - guide/standalone-components#getting-started-with-standalone-components\n - guide/standalone-components#lazy-loading-a-standalone-component\n - guide/standalone-components#lazy-loading-and-default-exports\n - guide/standalone-components#lazy-loading-many-routes-at-once\n - guide/standalone-components#providing-services-to-a-subset-of-routes\n - guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\n - guide/standalone-components#routing-and-lazy-loading\n - guide/standalone-components#standalone-components-for-library-authors\n - guide/standalone-components#standalone-injectors\n - guide/standalone-components#the-standalone-flag-and-component-imports\n - guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\n - guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\n-->"}
