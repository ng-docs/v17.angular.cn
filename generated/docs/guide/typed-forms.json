{"id":"guide/typed-forms","title":"类型化表单","contents":"<div class=\"content\">\n  <h1 id=\"typed-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"175jtor9ctchmei8ajglnlv07\">类型化表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#typed-forms\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hurgupejyhzz46qvyddgx6ws\">从 Angular 14 开始，响应式表单默认是严格类型的。</p>\n<p><a id=\"prerequisites\"></a></p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7uakl97kk0qcgcj9dby8bmhe0\">作为本指南的背景，你应该已经熟悉<a href=\"guide/reactive-forms\" title=\"响应式表单\">Angular 响应式表单</a>。</p>\n<p><a id=\"intro\"></a></p>\n<h2 id=\"overview-of-typed-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egd6w8t4042jhomymsq925emk\">类型化表单概览<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#overview-of-typed-forms\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"video-container\">\n<video controls>\n      <source src=\"https://videos.angular.cn/L-odCf4MfJc.webm\" type=\"video/webm\">\n      <source src=\"https://videos.angular.cn/L-odCf4MfJc.mp4\" type=\"video/mp4\">\n      <track src=\"/assets/videos/L-odCf4MfJc.en.vtt\" label=\"English\" kind=\"subtitles\" srclang=\"en\">\n      <track src=\"/assets/videos/L-odCf4MfJc.cn.vtt\" label=\"简体中文\" kind=\"subtitles\" srclang=\"zh-CN\" default>\n      <track src=\"/assets/videos/L-odCf4MfJc.tw.vtt\" label=\"正體中文\" kind=\"subtitles\" srclang=\"zh-TW\">\n    </video>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24orea3n2d4rbjpod82jdhr2o\">使用 Angular 响应式表单，你可以显式指定<em>表单模型</em>。作为一个简单的例子，考虑这个基本的用户登录表单：</p>\n<code-example language=\"ts\">\nconst login = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(''),\n    password: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(''),\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86w8gl5wbhtd4vd4tolqltcla\">Angular 提供了许多 API 来与此 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 交互。例如，你可以调用 <code>login.value</code> 、 <code>login.controls</code> 、 <code>login.patchValue</code> 等。（有关完整的 API 参考，请参阅<a href=\"api/forms/FormGroup\">API 文档</a>。）</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ws75x6np47xa9xau00oabh4w\">在以前的 Angular 版本中，这些 API 中的大多数都在其类型中的某处包含 <code>any</code>，并且与控件结构或值本身的交互不是类型安全的。例如：你可以编写以下无效代码：</p>\n<code-example language=\"ts\">\nconst emailDomain = login.value.email.domain;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ipo0eorvgnsj1dlx03pnmpfw\">使用严格类型的响应式表单时，上面的代码不会编译，因为 <code><a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a></code> 上并没有 <code>domain</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alecsnckuqbm49g8okmssvfe0\">除了增加安全性之外，这些类型还支持各种其他改进，例如 IDE 中更好的自动完成，以及显式指定表单结构的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mhbbw4ewy5ehbsu9a2hjbo82\">这些改进当前仅适用于<em>响应</em>式表单（不适用于<a href=\"guide/forms\" title=\"表单指南\"><em>模板驱动的</em>表单</a>）。</p>\n<p><a id=\"automated-migration\"></a></p>\n<h2 id=\"automated-untyped-forms-migration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l8wid60gzsixhmk18c9vf8tp\">自动无类型表单迁移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#automated-untyped-forms-migration\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21wuc7wqq3uhnw352x48ih6m6\">升级到 Angular 14 时，包含的迁移将自动使用相应的无类型版本替换代码中的所有表单类。例如，上面的代码段将变为：</p>\n<code-example language=\"ts\">\nconst login = new <a href=\"api/forms/UntypedFormGroup\" class=\"code-anchor\">UntypedFormGroup</a>({\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: new <a href=\"api/forms/UntypedFormControl\" class=\"code-anchor\">UntypedFormControl</a>(''),\n    password: new <a href=\"api/forms/UntypedFormControl\" class=\"code-anchor\">UntypedFormControl</a>(''),\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwpukcmne5ptnw88m9klu7euo\">每个 <code>Untyped</code> 符号都与以前的 Angular 版本具有完全相同的语义，因此你的应用程序应该像以前一样继续编译。通过删除 <code>Untyped</code> 前缀，你可以增量启用这些类型。</p>\n<p><a id=\"form-control-inference\"></a></p>\n<h2 id=\"formcontrol-getting-started\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"odtu9v1yi5tw7nibkqoci8xq\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>：入门<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#formcontrol-getting-started\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkz3b24otzsfp6qqc6iuo6gox\">最简单的表单由单个控件组成：</p>\n<code-example language=\"ts\">\nconst <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a> = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('angularrox@gmail.com');\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwb2p0j9sprc98c0rgjkrmry2\">此控件将被自动推断为 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string|null&gt;</code> 类型。TypeScript 会在整个<a href=\"api/forms/FormControl\"><code>FormControl</code> API</a>中自动强制执行此类型，例如 <code>email.value</code> 、 <code>email.valueChanges</code> 、 <code>email.setValue(...)</code> 等。</p>\n<h3 id=\"nullability\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kgd2h0rvg7onaehvqwmq765e\">可空性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#nullability\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3b1au1jeo6zyq1oicup9gafo3\">你可能想知道：为什么此控件的类型包含 <code>null</code> ？这是因为控件可以随时通过调用 reset 变为 <code>null</code>：</p>\n<code-example language=\"ts\">\nconst <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a> = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('angularrox@gmail.com');\nemail.reset();\nconsole.log(email.value); // null\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am8asgd58iggyemxg21p4f0mp\">TypeScript 将强制你始终处理控件已变为 <code>null</code> 的可能性。如果要使此控件不可为空，可以用 <code>nonNullable</code> 选项。这将导致控件重置为其初始值，而不是 <code>null</code>：</p>\n<code-example language=\"ts\">\nconst <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a> = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('angularrox@gmail.com', {nonNullable: true});\nemail.reset();\nconsole.log(email.value); // angularrox@gmail.com\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dek6ampjj0jd5hi0ge9nm18g\">重申一下，此选项会在调用 <code>.reset()</code> 时影响表单的运行时行为，应小心翻转。</p>\n<h3 id=\"specifying-an-explicit-type\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arg7huqkaaqwn04mks3v9gi93\">指定显式类型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#specifying-an-explicit-type\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8ce61jskq1qk0x0q0wa2v479\">可以指定类型，而不是依赖推理。考虑一个初始化为 <code>null</code> 的控件。因为初始值为 <code>null</code>，所以 TypeScript 将推断 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;null&gt;</code>，这比我们想要的要窄。</p>\n<code-example language=\"ts\">\nconst <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a> = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(null);\nemail.setValue('angularrox@gmail.com'); // Error!\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46ne9y7d11p72svkeyq5lhig8\">为防止这种情况，我们将类型显式指定为 <code>string|null</code>：</p>\n<code-example language=\"ts\">\nconst <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a> = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string|null&gt;(null);\nemail.setValue('angularrox@gmail.com');\n</code-example>\n<p><a id=\"form-array\"></a></p>\n<h2 id=\"formarray-dynamic-homogenous-collections\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96lgzjoy3u0zef4jpe60wfa2k\"><code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code>：动态的、同质的集合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#formarray-dynamic-homogenous-collections\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boxyvsim4cmqprft00kc2b6xx\"><code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code> 包含一个开放式控件列表。type 参数对应于每个内部控件的类型：</p>\n<code-example language=\"ts\">\nconst names = new <a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a>([new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('Alex')]);\nnames.push(new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('Jess'));\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6phad1fw4u75bwxanrg8dmgwa\">此 <code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code> 将具有内部控件类型 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string|null&gt;</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xvm6iihmonxq1ut0gwdht94f\">如果你想在数组中有多个不同的元素类型，则必须使用 <code><a href=\"api/forms/UntypedFormArray\" class=\"code-anchor\">UntypedFormArray</a></code>，因为 TypeScript 无法推断哪种元素类型将出现在哪个位置。</p>\n<p><a id=\"form-group-record\"></a></p>\n<h2 id=\"formgroup-and-formrecord\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59kyo69d9yb4aolsld0g341p6\"><code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 和 <code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#formgroup-and-formrecord\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"798jhvmypyyzsk0gzigrqxfob\">Angular 为具有枚举键集的表单提供了 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 类型，并为开放式或动态组提供了一种名为 <code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code> 的类型。</p>\n<h3 id=\"partial-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eo94hfug64lgcdlxirspew51e\">部分值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#partial-values\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wb9lhqxsaqprpj7k22w60yup\">再次考虑一个登录表单：</p>\n<code-example language=\"ts\">\nconst login = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {nonNullable: true}),\n    password: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {nonNullable: true}),\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ga3cqo4eqtk54g1rtbvlgre5\">在任何 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 上，都<a href=\"api/forms/FormGroup\">可以禁用控件</a>。任何禁用的控件都不会出现在组的值中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xcktxfvj7kd2pctgzii0o2ls\">因此，<code>login.value</code> 的类型是 <code>Partial&lt;{<a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: string, password: string}&gt;</code>。这种类型的 <code>Partial</code> 意味着每个成员可能是未定义的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bntzykgi9khu0gafgp04fsv43\">更具体地说，<code>login.value.email</code> 的类型是 <code>string|undefined</code>，TypeScript 将强制你处理可能 <code>undefined</code> 的值（如果你启用了 <code>strictNullChecks</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bhwsth85m6s8lwqzgl4p5zku\">如果你想访问<em>包括</em>禁用控件的值，从而绕过可能的 <code>undefined</code> 字段，可以用 <code>login.getRawValue()</code>。</p>\n<h3 id=\"optional-controls-and-dynamic-groups\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8m7j56pql33ve8v3d3pkcycv\">可选控件和动态组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#optional-controls-and-dynamic-groups\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d40wzg1mqx54rrg56zm7wlsmg\">某些表单的控件可能存在也可能不存在，可以在运行时添加和删除。你可以用<em>可选字段</em>来表示这些控件：</p>\n<code-example language=\"ts\">\ninterface LoginForm {\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string&gt;;\n    password?: <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string&gt;;\n}\n\nconst login = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>&lt;LoginForm&gt;({\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {nonNullable: true}),\n    password: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {nonNullable: true}),\n});\n\nlogin.removeControl('password');\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14tbqevg6im62b7apyos0g1dg\">在这个表单中，我们明确地指定了类型，这使我们可以将 <code>password</code> 控件设为可选的。TypeScript 会强制只有可选控件才能被添加或删除。</p>\n<h3 id=\"formrecord\"><code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#formrecord\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1vyq6hgx1cav37kjuwv6kzu6r\">某些 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 的用法不符合上述模式，因为键是无法提前知道的。<code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code> 类就是为这种情况设计的：</p>\n<code-example language=\"ts\">\nconst addresses = new <a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a>&lt;<a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>&lt;string|null&gt;&gt;({});\naddresses.addControl('Andrew', new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('2340 Folsom St'));\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"agw806c6lshija806ejmdyad6\">任何 <code>string|null</code> 类型的控件都可以添加到此 <code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90a9rpcbuse3p0ymfhurxh0b0\">如果你需要一个动态（开放式）和异构（控件是不同类型）的 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>，则无法提升为类型安全的，这时你应该使用 <code><a href=\"api/forms/UntypedFormGroup\" class=\"code-anchor\">UntypedFormGroup</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wguth93oo1pufnavnr9vtqos\"><code><a href=\"api/forms/FormRecord\" class=\"code-anchor\">FormRecord</a></code> 也可以用 <code><a href=\"api/forms/FormBuilder\" class=\"code-anchor\">FormBuilder</a></code> 构建：</p>\n<code-example language=\"ts\">\nconst addresses = fb.record({'Andrew': '2340 Folsom St'});\n</code-example>\n<h2 id=\"formbuilder-and-nonnullableformbuilder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw5mbv4ynrzcvwx5z2obgcul\"><code><a href=\"api/forms/FormBuilder\" class=\"code-anchor\">FormBuilder</a></code> 和 <code><a href=\"api/forms/NonNullableFormBuilder\" class=\"code-anchor\">NonNullableFormBuilder</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/typed-forms#formbuilder-and-nonnullableformbuilder\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpy52010cdfjwwykjuejn4sbs\"><code><a href=\"api/forms/FormBuilder\" class=\"code-anchor\">FormBuilder</a></code> 类已升级为支持新增的类型的版本，方式与上面的示例相同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tzoraqh6z6fvi2gr3zcbz87c\">此外，还有一个额外的构建器：<code><a href=\"api/forms/NonNullableFormBuilder\" class=\"code-anchor\">NonNullableFormBuilder</a></code>。它是在所有控件都上指定 <code>{nonNullable: true}</code> 的简写，用来在大型非空表单中消除主要的样板代码。你可以用 <code><a href=\"api/forms/FormBuilder\" class=\"code-anchor\">FormBuilder</a></code> 上的 <code>nonNullable</code> 属性访问它：</p>\n<code-example language=\"ts\">\nconst fb = new <a href=\"api/forms/FormBuilder\" class=\"code-anchor\">FormBuilder</a>();\nconst login = fb.nonNullable.group({\n    <a href=\"api/forms/EmailValidator\" class=\"code-anchor\">email</a>: '',\n    password: '',\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2qaqdmxvxdznbj529lslrq4a\">在上面的示例中，两个内部控件都将不可为空（即将设置 <code>nonNullable</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmseqkl5e2htctkwfklhi7095\">你还可以用名称 <code><a href=\"api/forms/NonNullableFormBuilder\" class=\"code-anchor\">NonNullableFormBuilder</a></code> 注入它。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Tue May 10 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/forms/EmailValidator\n - api/forms/FormArray\n - api/forms/FormBuilder\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/forms/FormRecord\n - api/forms/NonNullableFormBuilder\n - api/forms/UntypedFormArray\n - api/forms/UntypedFormControl\n - api/forms/UntypedFormGroup\n - guide/forms\n - guide/reactive-forms\n - guide/typed-forms#automated-untyped-forms-migration\n - guide/typed-forms#formarray-dynamic-homogenous-collections\n - guide/typed-forms#formbuilder-and-nonnullableformbuilder\n - guide/typed-forms#formcontrol-getting-started\n - guide/typed-forms#formgroup-and-formrecord\n - guide/typed-forms#formrecord\n - guide/typed-forms#nullability\n - guide/typed-forms#optional-controls-and-dynamic-groups\n - guide/typed-forms#overview-of-typed-forms\n - guide/typed-forms#partial-values\n - guide/typed-forms#prerequisites\n - guide/typed-forms#specifying-an-explicit-type\n - guide/typed-forms#typed-forms\n-->"}
